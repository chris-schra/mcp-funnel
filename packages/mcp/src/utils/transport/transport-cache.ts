/**
 * Transport instance cache management for singleton behavior.
 *
 * Provides instance tracking and cache key generation to ensure transport reuse
 * when configurations are identical. Uses WeakMaps to track unique identities
 * of auth providers and token storage instances.
 * @internal
 */

import type { IAuthProvider, ITokenStorage } from '@mcp-funnel/core';
import type { TransportConfig } from '@mcp-funnel/models';
import type { FactoryTransport } from '../../types/index.js';

/**
 * Dependencies that can be injected into transports for authentication.
 * @public
 */
export interface TransportFactoryDependencies {
  /** Optional authentication provider for authenticated transports */
  authProvider?: IAuthProvider;
  /** Optional token storage for persisting credentials */
  tokenStorage?: ITokenStorage;
}

/**
 * Transport instance cache for singleton behavior.
 * @internal
 */
const transportCache = new Map<string, FactoryTransport>();

/**
 * WeakMaps to track unique IDs for provider/storage instances for cache key generation.
 *
 * This ensures different instances with the same configuration get separate cache entries.
 * @internal
 */
const authProviderIds = new WeakMap<IAuthProvider, string>();
const tokenStorageIds = new WeakMap<ITokenStorage, string>();

/**
 * Counter for generating unique instance IDs.
 * @internal
 */
let instanceIdCounter = 0;

/**
 * Gets or creates a unique ID for an auth provider instance.
 *
 * Uses WeakMap to track instance identity without preventing garbage collection.
 * @param provider - Auth provider instance
 * @returns Unique ID string for this provider instance
 * @internal
 */
function getAuthProviderInstanceId(provider: IAuthProvider): string {
  let id = authProviderIds.get(provider);
  if (!id) {
    id = `auth_provider_${++instanceIdCounter}`;
    authProviderIds.set(provider, id);
  }
  return id;
}

/**
 * Gets or creates a unique ID for a token storage instance.
 *
 * Uses WeakMap to track instance identity without preventing garbage collection.
 * @param storage - Token storage instance
 * @returns Unique ID string for this storage instance
 * @internal
 */
function getTokenStorageInstanceId(storage: ITokenStorage): string {
  let id = tokenStorageIds.get(storage);
  if (!id) {
    id = `token_storage_${++instanceIdCounter}`;
    tokenStorageIds.set(storage, id);
  }
  return id;
}

/**
 * Generates a cache key for transport singleton behavior.
 *
 * Combines serialized config with unique instance IDs for auth provider and token storage
 * to ensure different provider/storage instances don't share cached transports even with
 * identical configurations.
 * @param config - Transport configuration to include in key
 * @param dependencies - Optional auth provider and token storage
 * @returns Unique cache key string for this config/dependency combination
 * @public
 */
export function generateCacheKey(
  config: TransportConfig,
  dependencies?: TransportFactoryDependencies,
): string {
  const configKey = JSON.stringify(config);
  const authKey = dependencies?.authProvider
    ? `auth:${getAuthProviderInstanceId(dependencies.authProvider)}`
    : 'no-auth';
  const storageKey = dependencies?.tokenStorage
    ? `storage:${getTokenStorageInstanceId(dependencies.tokenStorage)}`
    : 'no-storage';
  return `${configKey}:${authKey}:${storageKey}`;
}

/**
 * Gets a cached transport instance if it exists.
 * @param cacheKey - Cache key generated by generateCacheKey
 * @returns Cached transport instance or undefined if not found
 * @public
 */
export function getCachedTransport(cacheKey: string): FactoryTransport | undefined {
  return transportCache.get(cacheKey);
}

/**
 * Stores a transport instance in the cache.
 * @param cacheKey - Cache key generated by generateCacheKey
 * @param transport - Transport instance to cache
 * @public
 */
export function setCachedTransport(cacheKey: string, transport: FactoryTransport): void {
  transportCache.set(cacheKey, transport);
}

/**
 * Clears the transport cache.
 *
 * Useful for testing and cleanup scenarios where cached transports should be invalidated.
 * @public
 */
export function clearTransportCache(): void {
  transportCache.clear();
}

/**
 * Gets the current size of the transport cache.
 *
 * Useful for monitoring and debugging cache behavior.
 * @returns Number of cached transport instances
 * @public
 */
export function getTransportCacheSize(): number {
  return transportCache.size;
}
